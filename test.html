<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Multi-Line Roster Test</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;700&display=swap" rel="stylesheet">
    <style>
        body { font-family: 'Inter', sans-serif; }
        select:disabled, input:disabled, button:disabled {
            background-color: #e9ecef;
            opacity: 0.7;
            cursor: not-allowed;
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center min-h-screen p-4">

    <div class="bg-white p-8 rounded-lg shadow-md max-w-lg w-full text-center">
        <h1 class="text-xl sm:text-2xl font-bold text-gray-800 mb-4">Multi-Line Roster Test</h1>
        
        <div class="space-y-4 text-left">
            <div>
                <label for="sheetName" class="block text-sm font-medium text-gray-700 mb-1">Which roster?</label>
                <select id="sheetName" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" disabled>
                    <option>Loading...</option>
                </select>
            </div>
            <div class="grid grid-cols-2 gap-4">
                <div>
                    <label for="startDate" class="block text-sm font-medium text-gray-700 mb-1">Start Date</label>
                    <input type="date" id="startDate" class="w-full border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" disabled>
                </div>
                <div>
                    <label for="endDate" class="block text-sm font-medium text-gray-700 mb-1">End Date</label>
                    <input type="date" id="endDate" class="w-full border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500" disabled>
                </div>
            </div>
             <div>
                <label for="lineNumber" class="block text-sm font-medium text-gray-700 mb-1">Starting Line:</label>
                <input type="number" id="lineNumber" value="8" class="w-full px-3 py-2 border border-gray-300 rounded-lg focus:ring-blue-500 focus:border-blue-500">
            </div>
        </div>

        <button id="fetchBtn" class="mt-6 w-full bg-green-600 text-white font-bold py-3 px-4 rounded-lg hover:bg-green-700 transition-colors">Fetch Data</button>

        <p id="status-text" class="text-gray-600 my-6 h-5">
             Select a roster and enter a starting line.
        </p>

        <div id="link-container" class="flex flex-col sm:flex-row gap-4 justify-center"></div>
        
        <div id="raw-data-output" class="mt-6 text-left hidden">
            <h2 id="rawDataHeader" class="text-lg font-semibold text-gray-700 mb-2">Raw Data</h2>
            <pre class="bg-gray-100 p-4 rounded-lg text-sm whitespace-pre-wrap break-all"></pre>
        </div>
    </div>

    <!-- Date Sanity Check Modal -->
    <div id="dateSanityCheckModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full hidden z-50 flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
            <div class="text-center">
                <h3 class="text-lg leading-6 font-medium text-gray-900">Incorrect Start Date</h3>
                <div class="mt-2 px-7 py-3"><p class="text-sm text-gray-500">The selected start date is not the beginning of a fortnight. Please choose one of the correct dates below to continue.</p></div>
                <div class="items-center px-4 py-3 space-y-2">
                    <button id="modalPrevDateBtn" class="w-full px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-blue-700"></button>
                    <button id="modalNextDateBtn" class="w-full px-4 py-2 bg-blue-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-blue-700"></button>
                    <button id="modalCancelBtn" class="w-full px-4 py-2 bg-gray-200 text-gray-800 text-base font-medium rounded-md shadow-sm hover:bg-gray-300">Cancel</button>
                </div>
            </div>
        </div>
    </div>

    <!-- Re-download Confirmation Modal -->
    <div id="reDownloadModal" class="fixed inset-0 bg-gray-600 bg-opacity-50 h-full w-full hidden z-50 flex items-center justify-center">
        <div class="bg-white p-6 rounded-lg shadow-xl w-full max-w-sm">
            <div class="text-center">
                <h3 id="reDownloadTitle" class="text-lg leading-6 font-medium text-gray-900">Re-download File?</h3>
                <div class="mt-2 px-7 py-3"><p id="reDownloadText" class="text-sm text-gray-500">Do you want to download this file again?</p></div>
                <div class="items-center px-4 py-3 flex justify-center gap-4">
                    <button id="reDownloadConfirmBtn" class="px-6 py-2 bg-blue-500 text-white text-base font-medium rounded-md shadow-sm hover:bg-blue-700">Yes</button>
                    <button id="reDownloadCancelBtn" class="px-6 py-2 bg-gray-200 text-gray-800 text-base font-medium rounded-md shadow-sm hover:bg-gray-300">No</button>
                </div>
            </div>
        </div>
    </div>


    <script>
        document.addEventListener('DOMContentLoaded', () => {
            const AppState = {
                gasUrl: 'https://script.google.com/macros/s/AKfycbxYIvUCKHqVT5ygPoXSi1F1bkvOOg41eaX-2UQq8Pfr9JHrxd7bALo1Vaey9FNrk3Ds/exec',
                rosterDates: [],
                blockDataCache: {}
            };

            const statusText = document.getElementById('status-text');
            const sheetSelect = document.getElementById('sheetName');
            const startDateInput = document.getElementById('startDate');
            const endDateInput = document.getElementById('endDate');
            
            const isIOS = (/iPad|iPhone|iPod/.test(navigator.userAgent) && !window.MSStream) || (navigator.platform === 'MacIntel' && navigator.maxTouchPoints > 1);
            if (isIOS) {
                document.getElementById('reDownloadTitle').textContent = 'Re-import Event/s?';
                document.getElementById('reDownloadText').textContent = 'Do you want to re-import the event/s again?';
            }
            
            async function initialize() {
                sheetSelect.innerHTML = '<option>Loading rosters...</option>';
                try {
                    const [sheetsResponse, blocksResponse] = await Promise.all([
                        fetch(`${AppState.gasUrl}?action=getSheets`),
                        fetch(`${AppState.gasUrl}?action=getBlocks`)
                    ]);

                    const sheetsResult = await sheetsResponse.json();
                    if (!sheetsResult.success) throw new Error(sheetsResult.error);
                    
                    const blocksResult = await blocksResponse.json();
                    if (!blocksResult.success) throw new Error(blocksResult.error);

                    AppState.rosterDates = sheetsResult.data
                        .map(name => parseDMY(name))
                        .filter(date => date !== null)
                        .sort((a, b) => a - b);
                    
                    AppState.blockDataCache = blocksResult.data;
                    
                    sheetSelect.innerHTML = '<option value="">-- Select a roster --</option>';
                    sheetsResult.data.forEach(name => {
                        const option = document.createElement('option');
                        option.value = name;
                        option.textContent = name;
                        sheetSelect.appendChild(option);
                    });
                    sheetSelect.disabled = false;
                } catch(error) {
                    console.error('Initialization Error:', error);
                    sheetSelect.innerHTML = `<option>Error loading rosters</option>`;
                }
            }

            function parseDMY(dateString) {
                const parts = dateString.match(/(\d+)/g);
                if (!parts || parts.length < 3) return null;
                return new Date(parts[2], parts[1] - 1, parts[0]);
            }

             sheetSelect.addEventListener('change', () => {
                const selectedRoster = sheetSelect.value;
                if (!selectedRoster) {
                    [startDateInput, endDateInput].forEach(el => el.disabled = true);
                    return;
                }
                
                const rosterStartDate = parseDMY(selectedRoster);
                if (rosterStartDate) {
                    const formattedDate = toInputDateString(rosterStartDate);
                    startDateInput.value = formattedDate;
                    startDateInput.min = formattedDate;
                    endDateInput.min = formattedDate;

                    const currentIndex = AppState.rosterDates.findIndex(d => d.getTime() === rosterStartDate.getTime());

                    if (currentIndex > -1 && currentIndex < AppState.rosterDates.length - 1) {
                        const nextRosterStartDate = AppState.rosterDates[currentIndex + 1];
                        const maxEndDate = new Date(nextRosterStartDate);
                        maxEndDate.setDate(maxEndDate.getDate() - 1);
                        endDateInput.max = toInputDateString(maxEndDate);

                        const latestStartDate = new Date(maxEndDate);
                        latestStartDate.setDate(latestStartDate.getDate() - 13);
                        startDateInput.max = toInputDateString(latestStartDate);
                    } else {
                        endDateInput.removeAttribute('max');
                        startDateInput.removeAttribute('max');
                    }
                    
                    const defaultEndDate = new Date(rosterStartDate);
                    defaultEndDate.setDate(rosterStartDate.getDate() + 13);
                    endDateInput.value = toInputDateString(defaultEndDate);
                    adjustEndDate();
                }
                [startDateInput, endDateInput].forEach(el => el.disabled = false);
            });

            const handleDateChange = () => { adjustEndDate(); };
            startDateInput.addEventListener('input', handleDateChange);
            endDateInput.addEventListener('input', handleDateChange);

            function adjustEndDate() {
                let start = new Date(startDateInput.value + 'T00:00:00');
                let end = new Date(endDateInput.value + 'T00:00:00');

                if (isNaN(start.getTime())) return;

                if (isNaN(end.getTime()) || end < start) {
                    end = new Date(start);
                    end.setDate(start.getDate() + 13);
                }

                const oneDay = 1000 * 60 * 60 * 24;
                const diffDays = Math.round((end - start) / oneDay) + 1;
                const numFortnights = Math.ceil(diffDays / 14);
                const totalDays = numFortnights * 14;
                let newEndDate = new Date(start);
                newEndDate.setDate(start.getDate() + totalDays - 1);

                const maxDateStr = endDateInput.max;
                if (maxDateStr) {
                    const maxDate = new Date(maxDateStr + 'T00:00:00');
                    if (newEndDate > maxDate) newEndDate = maxDate;
                }

                endDateInput.value = toInputDateString(newEndDate);
            }

            const toInputDateString = (date) => {
                const year = date.getFullYear();
                const month = ('0' + (date.getMonth() + 1)).slice(-2);
                const day = ('0' + date.getDate()).slice(-2);
                return `${year}-${month}-${day}`;
            }

            // --- ICS and Download Helper Functions ---
            const toIcsUtcDate = (date) => date.toISOString().replace(/[-:.]/g, '').slice(0, 15) + 'Z';
            const toIcsFloatingDate = (date) => {
                const year = date.getFullYear();
                const month = ('0' + (date.getMonth() + 1)).slice(-2);
                const day = ('0' + date.getDate()).slice(-2);
                const hours = ('0' + date.getHours()).slice(-2);
                const minutes = ('0' + date.getMinutes()).slice(-2);
                const seconds = ('0' + date.getSeconds()).slice(-2);
                return `${year}${month}${day}T${hours}${minutes}${seconds}`;
            };
            const toIcsAllDayDate = (date) => {
                const year = date.getFullYear();
                const month = ('0' + (date.getMonth() + 1)).slice(-2);
                const day = ('0' + date.getDate()).slice(-2);
                return `${year}${month}${day}`;
            };
            const parseShiftDetails = (content) => {
                const regex = /^(\d{2}:\d{2})\s*-\s*(\d{2}:\d{2}L?)(?:\s+(.+))?/;
                return content.match(regex);
            };
            const generateIcsContent = (events, isAllDay = false) => {
                const now = new Date();
                let icsLines = ['BEGIN:VCALENDAR', 'VERSION:2.0', 'PRODID:-//Test//MyWebApp//EN'];
                events.forEach(event => {
                    icsLines.push('BEGIN:VEVENT', `UID:${event.uid}`, `DTSTAMP:${toIcsUtcDate(now)}`);
                    if (isAllDay) {
                        icsLines.push(`DTSTART;VALUE=DATE:${toIcsAllDayDate(event.start)}`);
                    } else {
                        icsLines.push(`DTSTART:${toIcsFloatingDate(event.start)}`, `DTEND:${toIcsFloatingDate(event.end)}`);
                    }
                    icsLines.push(`SUMMARY:${event.summary}`);
                    if (event.description) {
                        icsLines.push(`DESCRIPTION:${event.description}`);
                    }
                    icsLines.push('END:VEVENT');
                });
                icsLines.push('END:VCALENDAR');
                return icsLines.join('\r\n');
            };
            const createDownloadLink = (filename, linkText, icsContent) => {
                const blob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.textContent = linkText;
                a.download = filename;
                a.className = 'inline-block bg-blue-600 text-white font-bold py-3 px-6 rounded-lg hover:bg-blue-700 transition-colors';
                a.addEventListener('click', (e) => {
                    if (a.dataset.clicked === 'true') {
                        e.preventDefault();
                        const modal = document.getElementById('reDownloadModal');
                        modal.classList.remove('hidden');
                        const confirmBtn = document.getElementById('reDownloadConfirmBtn');
                        const cancelBtn = document.getElementById('reDownloadCancelBtn');
                        const newConfirmBtn = confirmBtn.cloneNode(true);
                        confirmBtn.parentNode.replaceChild(newConfirmBtn, confirmBtn);
                        newConfirmBtn.onclick = () => {
                            const freshBlob = new Blob([icsContent], { type: 'text/calendar;charset=utf-8' });
                            const freshUrl = URL.createObjectURL(freshBlob);
                            window.location.href = freshUrl;
                            setTimeout(() => URL.revokeObjectURL(freshUrl), 200);
                            modal.classList.add('hidden');
                        };
                        cancelBtn.onclick = () => {
                            modal.classList.add('hidden');
                        };
                    } else {
                        a.dataset.clicked = 'true';
                        a.classList.remove('bg-blue-600', 'hover:bg-blue-700');
                        a.classList.add('bg-gray-400');
                    }
                });
                document.getElementById('link-container').appendChild(a);
            };

            function isValidFortnightStartDate(date) {
                const referenceDate = AppState.rosterDates[0];
                if (!referenceDate) return false;
                const oneDay = 1000 * 60 * 60 * 24;
                const diffDays = Math.round((date.getTime() - referenceDate.getTime()) / oneDay);
                return diffDays % 14 === 0;
            }

            function checkAndCorrectDate(onSuccessCallback, onCancelCallback = () => {}) {
                const start = new Date(startDateInput.value + 'T00:00:00');

                if (isValidFortnightStartDate(start)) {
                    if (onSuccessCallback) onSuccessCallback();
                    return;
                }
                
                const oneDay = 1000 * 60 * 60 * 24;
                const referenceDate = AppState.rosterDates[0];
                if (!referenceDate) {
                    statusText.textContent = "Roster reference date not found. Cannot validate.";
                    statusText.classList.add('text-red-500');
                    if(onCancelCallback) onCancelCallback();
                    return;
                }

                const diffDays = Math.round((start.getTime() - referenceDate.getTime()) / oneDay);
                const remainder = (diffDays % 14 + 14) % 14; 
                
                const prevDate = new Date(start);
                prevDate.setDate(start.getDate() - remainder);
                
                const nextDate = new Date(start);
                nextDate.setDate(start.getDate() + (14 - remainder));

                const modal = document.getElementById('dateSanityCheckModal');
                const prevBtn = document.getElementById('modalPrevDateBtn');
                const nextBtn = document.getElementById('modalNextDateBtn');
                const cancelBtn = document.getElementById('modalCancelBtn');

                prevBtn.textContent = `Use Previous: ${prevDate.toLocaleDateString()}`;
                nextBtn.textContent = `Use Next: ${nextDate.toLocaleDateString()}`;

                const newPrevBtn = prevBtn.cloneNode(true);
                const newNextBtn = nextBtn.cloneNode(true);
                const newCancelBtn = cancelBtn.cloneNode(true);
                prevBtn.parentNode.replaceChild(newPrevBtn, prevBtn);
                nextBtn.parentNode.replaceChild(newNextBtn, nextBtn);
                cancelBtn.parentNode.replaceChild(newCancelBtn, cancelBtn);

                newPrevBtn.onclick = () => {
                    startDateInput.value = toInputDateString(prevDate);
                    adjustEndDate();
                    if (onSuccessCallback) onSuccessCallback();
                    modal.classList.add('hidden');
                };
                newNextBtn.onclick = () => {
                    startDateInput.value = toInputDateString(nextDate);
                    adjustEndDate();
                    if (onSuccessCallback) onSuccessCallback();
                    modal.classList.add('hidden');
                };
                newCancelBtn.onclick = () => {
                    if (onCancelCallback) onCancelCallback();
                    modal.classList.add('hidden');
                };
                
                modal.classList.remove('hidden');
            }

            const fetchBtn = document.getElementById('fetchBtn');

            async function proceedWithFetch() {
                document.getElementById('link-container').innerHTML = '';
                const rawDataOutput = document.getElementById('raw-data-output');
                rawDataOutput.classList.add('hidden');
                rawDataOutput.querySelector('pre').textContent = '';

                const startLineNumber = parseInt(document.getElementById('lineNumber').value, 10);
                const sheetName = document.getElementById('sheetName').value;
                const rosterStartDate = new Date(document.getElementById('startDate').value + 'T00:00:00');
                const rosterEndDate = new Date(document.getElementById('endDate').value + 'T00:00:00');
                
                if (isNaN(startLineNumber) || !sheetName || isNaN(rosterStartDate.getTime())) {
                    statusText.textContent = 'Please fill in all fields.';
                    statusText.classList.add('text-red-500');
                    return;
                }

                statusText.textContent = `Fetching data starting from line ${startLineNumber}...`;
                statusText.classList.remove('text-red-500');
                document.getElementById('rawDataHeader').textContent = `Raw Data Starting from Line ${startLineNumber}`;

                try {
                    const response = await fetch(`${AppState.gasUrl}?action=getSheetData&sheetName=${encodeURIComponent(sheetName)}`);
                    const result = await response.json();
                    if (!result.success) throw new Error(result.error || 'Failed to fetch sheet data.');
                    const sheetData = result.data;
                    
                    console.log("Raw spreadsheet data:", sheetData);
                    
                    const allBlockStrings = AppState.blockDataCache[sheetName] || [];
                    const targetBlockString = allBlockStrings.find(bStr => {
                        const [start, end] = bStr.split('-').map(Number);
                        return !isNaN(start) && !isNaN(end) && startLineNumber >= start && startLineNumber <= end;
                    });

                    if (!targetBlockString) {
                        throw new Error(`Line ${startLineNumber} is not in a valid roster block for this sheet.`);
                    }
                    const [blockStart, blockEnd] = targetBlockString.split('-').map(Number);

                    const allShiftEvents = [];
                    const allDayOffEvents = [];
                    const dataMap = new Map(sheetData.map(row => [parseInt(row[0], 10), row]).filter(([key]) => !isNaN(key)));
                    
                    let dayCounter = 0;
                    let currentLine = startLineNumber;
                    for (let d = new Date(rosterStartDate); d <= rosterEndDate; d.setDate(d.getDate() + 1)) {
                        
                        if (dayCounter > 0 && dayCounter % 14 === 0) {
                            currentLine++;
                            if (currentLine > blockEnd) {
                                currentLine = blockStart;
                            }
                        }

                        const targetRow = dataMap.get(currentLine);
                        
                        if (targetRow) {
                            const dayOfWeek = d.getDay();
                            const dayInFortnight = dayCounter % 14;
                            const columnIndex = dayInFortnight < 7 ? dayOfWeek + 1 : dayOfWeek + 8;
                            const cellContent = String(targetRow[columnIndex] || '').trim();
                            const eventDate = new Date(d);
                            const shiftMatch = parseShiftDetails(cellContent);
                            
                            if (shiftMatch) {
                                const startTime = shiftMatch[1];
                                const endTime = shiftMatch[2]; // Contains optional 'L'
                                const rawDetails = shiftMatch[3] ? shiftMatch[3].trim() : '';
                                console.log(`[Line ${currentLine}, Day ${dayCounter}] 1. Raw Details:`, `"${rawDetails}"`);
                                
                                let summary = 'Shift';
                                let description = '';
                                
                                if (rawDetails) {
                                    const fxxRegex = /\s*F\d{1,2}$/;
                                    let detailsToProcess = rawDetails.replace(fxxRegex, '').trim();
                                    console.log(`[Line ${currentLine}, Day ${dayCounter}] 2. After F-Code Removal:`, `"${detailsToProcess}"`);


                                    if (detailsToProcess) {
                                        const firstSpaceIndex = detailsToProcess.indexOf(' ');
                                        if (firstSpaceIndex !== -1) {
                                            summary = detailsToProcess.substring(0, firstSpaceIndex).trim();
                                            description = detailsToProcess.substring(firstSpaceIndex + 1).trim();
                                        } else {
                                            summary = detailsToProcess;
                                        }
                                        console.log(`[Line ${currentLine}, Day ${dayCounter}] 3. Final Parsed Summary:`, `"${summary}"`, `Description:`, `"${description}"`);
                                    } else {
                                        console.log(`[Line ${currentLine}, Day ${dayCounter}] 3. No details left to process. Summary defaults to 'Shift'.`);
                                    }
                                } else {
                                     console.log(`[Line ${currentLine}, Day ${dayCounter}] 1. No raw details found.`);
                                }

                                const startDate = new Date(eventDate);
                                startDate.setHours(...startTime.split(':'), 0, 0);
                                const endDate = new Date(eventDate);
                                endDate.setHours(...endTime.replace('L','').split(':'), 0, 0);
                                if (endDate < startDate) endDate.setDate(endDate.getDate() + 1);

                                allShiftEvents.push({
                                    uid: `shift-${currentLine}-${dayCounter}@example.com`,
                                    start: startDate, end: endDate, summary: summary, description: description
                                });
                            } else if (cellContent.toUpperCase() === 'OFF' || cellContent.toUpperCase() === 'ADO') {
                                allDayOffEvents.push({
                                    uid: `dayoff-${currentLine}-${dayCounter}@example.com`,
                                    start: eventDate, summary: cellContent.toUpperCase()
                                });
                            }
                        }
                        dayCounter++;
                    }
                    
                    if (allShiftEvents.length > 0 || allDayOffEvents.length > 0) {
                        statusText.textContent = 'Found events! Click the links below to import.';
                        if (allShiftEvents.length > 0) createDownloadLink('shifts.ics', 'Import Shifts', generateIcsContent(allShiftEvents, false));
                        if (allDayOffEvents.length > 0) createDownloadLink('daysoff.ics', 'Import Days Off', generateIcsContent(allDayOffEvents, true));
                        const preElement = rawDataOutput.querySelector('pre');
                        preElement.textContent = JSON.stringify({ shifts: allShiftEvents, daysOff: allDayOffEvents }, null, 2);
                        rawDataOutput.classList.remove('hidden');
                    } else {
                        statusText.textContent = `No valid events found starting from line ${startLineNumber}.`;
                        statusText.classList.add('text-red-500');
                    }
                } catch (error) {
                    console.error('Test script failed:', error);
                    statusText.textContent = `Error: ${error.message}`;
                    statusText.classList.add('text-red-500');
                }
            }

            fetchBtn.addEventListener('click', () => {
                checkAndCorrectDate(proceedWithFetch);
            });

            initialize();
        });
    </script>
</body>
</html>

